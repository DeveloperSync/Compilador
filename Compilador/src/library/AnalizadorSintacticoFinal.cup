/* calculadora.cup */
/* http://www.academia.edu/4927379/JLex_y_Java_Cup_Instalacion_y_Ejemplo_2 */

/* Importamos las clases necesarias del paquete cup.jar */
import java_cup.runtime.*;

/**
    * Aquí ponemos el código que se usará para comenzar a parsear la entrada.
*/
parser code {:
        public static void main(String args[]) throws Exception {
            // La clase Yylex es creada por el analizador léxico
            // Jlex (ver sección siguiente).
            new parser(new Yylex(System.in)).parse();
        }
:}

/* Aquí especificamos los terminales del lenguaje. */
/**
    * Este terminal tiene un valor entero. Recuerda que le dábamos el valor
    * en el código del analizador léxico, al darle como parámetro un valor
    * entero al objeto Symbol.
*/
terminal Identificador, MAS, MENOS, POR, DIV, IGUAL, PUNTO, ABREPAR, CIERRAPAR, ABRELLAVE, CIERRALLAVE, TEXTDEC, FINLINEA, AND, OR, CLASE, ENTERO, LOGIC, FLOTANTE, RUTINA, TEXTO, NUMERO, IF, ELSE;

/* Lista de no terminales. */
/**
    * Aquí están los no terminales con valor entero, que son con los que
    * podemos hacer cálculos, y podemos escribirlos de la forma expr_e:l
    * (por ejemplo, no se podría hacer expr_list:l, ya que a ese no
    * terminal no le damos valor.
    */
non terminal String programa;
non terminal String declaracion_clase;
non terminal String cuerpo_clase;
non terminal String declaracion_metodo;
non terminal String cuerpo_metodo;
non terminal String declaracion_variables;
non terminal String declaracion_variable;
non terminal String tipo;
non terminal String tipo_numerico;
non terminal String texto;
non terminal String declarador_variable;
non terminal String declaracion_numero;
non terminal String declaracion_entero;
non terminal String declaracion_flotante;
non terminal String declaracion_texto;
non terminal String bloque_argumentos;
non terminal String argumentos;
non terminal String argumento;
non terminal String if_else;
non terminal String expresion;


/* Aquí especificamos la precedencia de los operadores. */
precedence left MAS;
precedence left MENOS;
precedence left POR;
precedence left DIV;

/**
    * Ahora comenzamos con las reglas de producción.
    */

/**
    * Estas dos reglas son nuevas. Nos sirven para encadenar varias
    * expresiones separadas por un ';'
    */

programa ::= declaracion_clase:a {: System.out.println("NombreClase" + a); :};
declaracion_clase ::= CLASE Identificador:a cuerpo_clase {: System.out.println("CuerpoClase" + a); :}; 
cuerpo_clase ::= ABRELLAVE CLASE:a CIERRALLAVE {: System.out.println("DeclaracionMetodo" + a); :};
